# Sorting(정렬)

데이터를 특정한 기준에 따라서 순서대로 나열하는 것이 정렬이다.

- 정렬알고리즘은 굉장히 다양한데 이중에서 선택정렬, 퀵정렬, 계수정렬만 여기서 배워본다고 한다.

- 파이써에서 제공하는 기본 정렬 라이브러리를 적용하면 좀 더 효과적인 정렬 수행방법도 있다고 함.

## Selection Sort(선택정렬)

가장 작은 데이터를 선택해 맨앞에 있는 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두번째 데이터와 바꾸는 과정을 반복하는 것

가장 원시적인 방법으로 매번 가장 작은 것을 선택한다는 의미로 선택정렬 알고리즘이라 부른다.

## Insertion Sort(삽입정렬)

데이터를 하나씩 확인하며 각 데이터를 적절한 위치에 삽입하는 정렬 방법

- 삽입정렬은 특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다.
- 삽입정렬은 두번째 데이터부터 시작한다. 왜냐하면 첫번째 데이터는 그 자체로 정렬되어 있다고 판단하기 때문이다.
- 선택정렬에 비해 실행시간 측면에서 더 효율적인 알고리즘으로 알려져 있다.
- 필요한 때만 위치를 바꾸게 되므로 데이터가 거의 정렬되어있을 때 훨씬 효율적이다.
- 선택정렬은 현재 데이터의 상태와 상관없이 무조건 모든 원소를 비교하고 위치를 바꾸는 반면 삽입정렬은 그렇지 않다.

## Quik Sort(퀵 정렬)

정렬 중 가장 많이 사용된다고 한다.
퀵정렬과 비교할 만큼 빠른 알고리즘으로는 병합정렬이라고 있단다.

"기준데이터를 설정하고 그 기준보다 큰 데이터와 작은데이터의 위치를 바꾸는 정렬방법"

1. 기준을 설정한 다음
2. 큰수와 작은수를 교환
3. 리스트를 반으로 나눔

- 이때 기준을 피벗이라고 표현함
- 피벗을 설정하고 리스트를 분할하는 방법에 따라서 여러가지 방식으로 퀵정렬을 구분하는데 , 여기서는 가장 대표적인 방식인 Hoare Partition(호어분할)방식을 기준으로 퀵정렬을 설명해준단다.
- 평균적인 시간복잡도는 N\*Log2N이나 최악은 N2이다

### 호어분할

리스트에서 첫번째 데이터를 피벗(pivot)으로 정한다.
-> 피벗 설정이후 왼쪽(첫번째를 피벗으로 지정했으니 index 1 부터)에서는 피벗보다 큰 데이터를 찾고, 오른쪽(len(list))에서부터 피벗보다 작은데이터를 찾는다. 그리고 두 데이터의 위치를 바꾼다.

이때 왼쪽부터 찾는값과 오른쪽부터 찾는값의 위치가 엇갈리게 될때 작은 데이터와 피벗의 위치를 서로 바꿔 준다.
이 과정을 반복하면 피벗에 대한 정렬이 수행된다.

## Merge Sort(병합정렬)

참고: https://www.daleseo.com/sort-merge/
주어진 list(배열)의 원소가 하나가 될때까지 쪼갠다.
그 다음 인접한 것들 끼리 하나씩 합치면서 작은 숫자가 앞의 순서(작은 index)를 가지도록 병합하는 과정을 거친다

## Count Sort(계수 정렬)

특정한 조건이 부합할때만 사용할 수 있지만 매우 빠른 정렬알고리즘이다.

- 데이터의 크기 범위가 제한되어 정수형태로 표현할 수 있을때만 사용가능하다
- 무한한 데이터 크기느 실수형 데이터가 주어지는 경우 계수정렬은 사용하기 어렵다.
- 일반적으로 가장 큰데이터와 가장 작은데이터의 차이가(1,000,000)을 넘지 않아야 한다
- 예를들어 성적을 정렬할때 성적(0~100점)의 범위로 인해 유용하다
- 이렇게 제한이 있는 경우는 계수정렬 이용시 모든 범위를 담을 수 있는 크기의 리스트(배열)를 선언해야하기 때문이다.

- 3가지 정렬알고리즘처럼 직접 데이터의 값을 비교한 뒤 위치를 변경하며 정렬하는방식이아니다.
- 별도의 리스트 선언하고 그 안에 정렬에 대한 정보를 담는것이다.
